<?php
//1. С помощью цикла while вывести все числа в промежутке от 0 до 100,
//которые делятся на 3 без остатка.

function getDivision($div, $max, $min = 0)
{
    $i = $min;
    $res = [];
    while ($i <= $max) {
        if ($i % $div == 0) {
            $res[] = $i;
        }
        $i++;
    }
    return $res;
}

$arr = getDivision(3, 100);
echo implode(', ', $arr);

//2. С помощью цикла do…while написать функцию для вывода чисел от 0 до 10,
//чтобы результат выглядел так:
//0 – это ноль.
//1 – нечетное число.
//2 – четное число.
//3 – нечетное число.
//…
//10 – четное число.

$arr = [];

function getParity($num = 10)
{
    $i = 0;
    $res = [];
    do {
        if ($i % 2 == 1) {
            $res[$i] = 'Это нечетное число';
        } else {
            $res[$i] = ($i == 0) ? 'Это ноль' : 'Это четное число';
        }
    } while (++$i <= $num);
    return $res;
}

$arr = getParity();
var_dump($arr);

//3. Объявить массив, в котором в качестве ключей будут использоваться названия областей,
//а в качестве значений – массивы с названиями городов из соответствующей области.
//Вывести в цикле значения массива, чтобы результат был таким:
//Московская область:
//Москва, Зеленоград, Клин
//Ленинградская область:
//Санкт-Петербург, Всеволожск, Павловск, Кронштадт
//Рязанская область … (названия городов можно найти на maps.yandex.ru)

require_once 'cities.php';

$res = '';
for ($i = 0; $i < count($cities); $i++) {
    $res .= key($cities) . ': <br>  ';        //вставляем название области по имени ключа
    //echo $res;
    foreach (current($cities) as $town) {
        $res .= $town . ', ';               // вставляется города через запятую
    }
    $res = substr($res, 0, -2);   // убираем последнюю запятую
    $res .= ' <br>';                          //на новую строку
    next($cities);      //сдвигаем указатель
}
echo $res;
echo ' <br>';
echo ' <br>';

//вторая реализация (два foreach, фильтр и  через функцию)
function getCities ($cities, $filtr = '//')
{
    $res = '';
    foreach ($cities as $oblast => $towns) {
        $res .= $oblast . ': <br>  ';        //вставляем название области по имени ключа
        //echo $res;
        foreach ($towns as $town) {
            if (preg_match($filtr, $town) ) {
                $res .= $town . ', ';               // вставляется города через запятую
            }
        }
        $res = substr($res, 0, -2);   // убираем последнюю запятую
        $res .= ' <br>';                         //на новую строку
    }
    return $res;
}
echo getCities($cities);
echo ' <br>';
echo ' <br>';

//4. Объявить массив, индексами которого являются буквы русского языка,
//а значениями – соответствующие латинские буквосочетания
//(‘а’=> ’a’, ‘б’ => ‘b’, ‘в’ => ‘v’, ‘г’ => ‘g’, …, ‘э’ => ‘e’, ‘ю’ => ‘yu’, ‘я’ => ‘ya’).
//Написать функцию транслитерации строк. Алгоритм должен быть эффективен по итерациям,
//если найдете готовую функцию, сделайте ее вторым вариантом, реализовать самому через цикл,
//строчку можно в массив через регулярку, но не обязательно (см.допматериалы)
require_once 'abc.php';

function translit($word, $abc)
{
    $str = '';
    for ($i = 0; $i < mb_strlen($word); $i++) {
        $letter = mb_substr($word, $i, 1);
        $str = (array_key_exists($letter, $abc)) ? $str . $abc[$letter] : $str . $letter;
    }
    return $str;
}

echo translit('как дела', $abc);
echo ' <br>';
echo ' <br>';


//5. Написать функцию, которая заменяет в строке пробелы на подчеркивания
//и возвращает видоизмененную строчку. Можно через str_replace

function replaceSymbol($str, $symbol, $newSymbol)
{
    return str_replace($symbol, $newSymbol, $str);
}

$str = 'Эта функция возвращает строку или массив, в котором все вхождения search в subject заменены на replace.';
echo replaceSymbol($str, ' ', '_');

//6. В имеющемся шаблоне сайта заменить статичное меню (ul – li) на генерируемое через PHP.
//Необходимо представить пункты меню как элементы массива и вывести их циклом.
//Подумать, как можно реализовать меню с вложенными подменю?
//Попробовать его реализовать через рекурсию.
//Чтобы любой уровень вложенности формировался по массиву.
//Не забудьте чтобы гиперссылки тоже были в массиве.

require_once 'templates/menuByArray.php';

function renderMenu(array $arr)
{
    $str = "<ul>";
    foreach ($arr as $key => $item) {
        if (!is_array($item)) {
            $str .= "<li><a {$item}>{$key}</a></li>";
        } else {
            $str .= " <li>{$key}";
            $str .= renderMenu($item);
            $str .= '</li>';
        }
    }
    $str .= '</ul>';
    return $str;
}

echo renderMenu($menu);

//7. *Вывести с помощью цикла for числа от 0 до 9, не используя тело цикла. Выглядеть должно так:
//for (…){ // здесь пусто}

for ($i=0; $i<10; print $i++) {
}
echo ' <br>';
echo ' <br>';

//8. *Повторить третье задание, но вывести на экран только города, начинающиеся с буквы «К».
$pattern = "/^К/";
echo getCities($cities, $pattern);
echo ' <br>';
echo ' <br>';

//9. *Объединить две ранее написанные функции в одну, которая получает строку на русском языке,
//производит транслитерацию и замену пробелов на подчеркивания
//(аналогичная задача решается при конструировании url-адресов на основе названия статьи в блогах)

function getName ($str, $abc){
    return replaceSymbol(translit($str,$abc), ' ', '_');
}

$str = '9. *Объединить две ранее написанные функции в одну, которая получает строку на русском языке, производит 
транслитерацию и замену пробелов на подчеркивания (аналогичная задача решается при конструировании url-адресов на 
основе названия статьи в блогах)';
echo getName($str, $abc);
echo ' <br>';
echo ' <br>';

//10. * Заполнить массив в 100 элементов случайными числами от 1 до 200, так, чтобы они не повторялись.
//Задача на бесконечный цикл while(true)
$arr =[];
$i=0;
while (true){
    $rand = rand(1,200);
    if (in_array($rand, $arr)) continue;
    $arr[]=$rand;
    if (count($arr)>=100) break;
}

var_dump($arr);


